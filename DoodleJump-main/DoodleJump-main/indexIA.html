<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Jump</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
        }

        #bestScoreContainer {
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
        }

        #canvasContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            margin-top: 50px;
        }

        #canvasContainer>div {
            display: inline-block;
        }
    </style>
</head>

<body>
    <div id="bestScoreContainer" style="text-align: center; color: white; font-size: 60px; margin-top: 20px;">
        Best Score: 0
    </div>
    <div id="canvasContainer"></div>
    <script>
        let numDoodles = 50;
        let canvasWidth = 80;
        let canvasHeight = 120;
        let bestScoreEver = 0;

        let container = document.getElementById("canvasContainer");

        for (let i = 0; i < numDoodles; i++) {

            let doodleContainer = document.createElement("div");
            doodleContainer.style.display = "inline block";
            let canvas = document.createElement("canvas");
            canvas.id = "canvas_" + i;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.margin = "5px";
            canvas.style.backgroundColor = "white";

            let scoreLabel = document.createElement("div");
            scoreLabel.id = "score_" + i;
            scoreLabel.style.color = "white";
            scoreLabel.style.fontSize = "50px";
            scoreLabel.style.marginTop = "5px";
            scoreLabel.textContent = "Score: 0";

            doodleContainer.appendChild(canvas);
            doodleContainer.appendChild(scoreLabel);

            container.appendChild(doodleContainer);
        }


        class Platform {
            constructor(x, y, width, height, type = "static") {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.isBroken = false;
                this.direction = 1;
            }

            Update(canvasWidth, fps) {
                if (this.type === "moving") {
                    this.x += this.direction * 100 / fps;
                    if (this.x <= 0 || this.x + this.width >= canvasWidth) {
                        this.direction *= -1;
                    }
                }
                if (this.type === "droping" && this.isTouch) {
                    this.y += 1;
                }
            }
            DrawPlateform(ctx, sprite) {
                let spriteX, spriteY, spriteWidth, spriteHeight;
                if (this.type === "static") {
                    spriteX = 1;
                    spriteY = 1;
                    spriteWidth = 57;
                    spriteHeight = 17;
                } else if (this.type === "moving") {
                    spriteX = 1;
                    spriteY = 19;
                    spriteWidth = 57;
                    spriteHeight = 17;
                } else if (this.type === "droping") {
                    spriteX = 1;
                    spriteY = 55;
                    spriteWidth = 57;
                    spriteHeight = 17;
                }

                ctx.drawImage(sprite, spriteX, spriteY, spriteWidth, spriteHeight, this.x, this.y, this.width, this.height);

            }
        }

        class Model {
            static GRAVITY = 30;
            static JUMP_FORCE = 950;
            static SPEED = 500;
            static LIMIT_BAR_Y = 400;

            constructor(id, weights1, biases1, weights2, biases2, weights3, biases3) {
                this._id = id;
                this._score = 0;

                this._lastScore = 0;
                this._inactiveFrames = 0;
                this._inactiveThreshold = 110;

                this._movementHistory = [];
                this._historyLimit = 150;

                this._direction = 0;
                this._gravitySpeed = 0;
                this._position = { x: 200, y: 300 };
                this.isJumping = false;
                this.isGameOver = false;
                this.platforms = this._GenerateInitialPlatforms();
                this.finishLine = { x: 0, y: -10000, width: 450, height: 10 };

                this.weights1 = weights1;
                this.biases1 = biases1;
                this.weights2 = weights2;
                this.biases2 = biases2;
                this.weights3 = weights3;
                this.biases3 = biases3;
            }
            get position() { return this._position; }

            get direction() { return this._direction; }
            set direction(value) { return this._direction = value; }

            BindDisplay(callback) {
                this.b_Display = callback;
            }

            Move(fps) {
                if (this.isGameOver) {
                    return;
                }

                this._gravitySpeed += Model.GRAVITY;
                this._position.y += this._gravitySpeed / fps;
                this._position.x += this._direction * Model.SPEED / fps;

                if (this._score === this._lastScore) {
                    this._inactiveFrames++;
                    if (this._inactiveFrames >= this._inactiveThreshold) {
                        this.isGameOver = true;
                        return;
                    }
                } else {
                    this._inactiveFrames = 0;
                }

                this._movementHistory.push(this._direction);
                if (this._movementHistory.length > this._historyLimit) {
                    this._movementHistory.shift();
                }
                if (this._isRepeatingMovement()) {
                    this.isGameOver = true;  // Termine la partie si comportement répétitif
                    return;
                }

                this._lastScore = this._score;


                if (this._position.y > 750) {
                    this.isGameOver = true;
                    return;
                }

                if (this._position.y <= this.finishLine.y) {
                    this.isGameOver = true;
                    return;
                }
                if (this._position.y < Model.LIMIT_BAR_Y) {
                    const deltaY = Model.LIMIT_BAR_Y - this._position.y;
                    this._position.y = Model.LIMIT_BAR_Y;

                    this._MovePlatformsDown(deltaY);
                }

                for (let platform of this.platforms) {
                    platform.Update(450, fps);
                }

                this._CheckPlatformCollision();

                if (this._position.x < 0) {
                    this._position.x = 450;
                } else if (this._position.x > 450) {
                    this._position.x = 0;
                }


                let inputVector = getInputVector(this.position, this.platforms);
                let hiddenLayer1 = linearTransformation(inputVector, this.weights1, this.biases1);
                let activatedHiddenLayer1 = applyReLU(hiddenLayer1);
                let hiddenLayer2 = linearTransformation(activatedHiddenLayer1, this.weights2, this.biases2);
                let activatedHiddenLayer2 = applyReLU(hiddenLayer2);
                let outputScores = outputLayer(activatedHiddenLayer2, this.weights3, this.biases3);
                let actionProbabilities = softmax(outputScores);
                let chosenAction = chooseAction(actionProbabilities);
                this._direction = chosenAction;

                this.b_Display(this._position, this._direction, this.platforms, this.finishLine);
            }
            _isRepeatingMovement() {
                if (this._movementHistory.length < this._historyLimit) return false;

                const firstMove = this._movementHistory[0];
                return this._movementHistory.every(move => move === firstMove);
            }


            _MovePlatformsDown(deltaY) {
                let platFormUnbreakable = this.platforms.filter(platform => platform.type != "breakable");
                for (let platform of this.platforms) {
                    platform.y += deltaY;

                    if (platform.y > 750) {

                        platform.y = 0;
                        platform.x = Math.random() * (450 - platform.width);
                        const randomOffsetY = Math.random() * 25 + 60;
                        platform.y -= randomOffsetY;

                        const randomValue = Math.random() * 100;
                        platform.type = randomValue < 80 ? "static" : randomValue < 90 ? "moving" : "droping";



                        platform.isTouch = false;

                    }
                }
                this._updateScore(deltaY);
                this.finishLine.y += deltaY;
            }

            _updateScore(deltaY) {
                if (deltaY > 0) {
                    this._score += deltaY;
                    let scoreElement = document.getElementById("score_" + this._id);
                    if (scoreElement) {
                        scoreElement.textContent = `Score: ${Math.floor(this._score)}`;
                    }
                }
            }

            _Jump() {
                this._gravitySpeed = -Model.JUMP_FORCE;
                this.isJumping = true;

            }

            _GenerateInitialPlatforms() {
                const initialPlatforms = [];
                const numberOfPlatforms = 8;
                const maxDistance = 150;

                let currentY = 750 - 200;

                initialPlatforms.push(new Platform(200, 700, 60, 17, "static"));
                for (let i = 0; i < numberOfPlatforms; i++) {
                    const x = Math.random() * (450 - 60);
                    const y = currentY;
                    const type = "static";

                    initialPlatforms.push(new Platform(x, y, 60, 17, type));
                    currentY -= maxDistance;
                }

                return initialPlatforms;
            }

            _CheckPlatformCollision() {
                for (let platform of this.platforms) {
                    if (
                        this._position.x + 45 > platform.x &&
                        this._position.x + 10 < platform.x + platform.width &&
                        this._position.y + 70 >= platform.y &&
                        this._position.y + 70 <= platform.y + platform.height &&
                        !platform.isBroken &&
                        this._gravitySpeed > 0
                    ) {
                        if (platform.type === "breakable") {
                            platform.isBroken = true;
                        }
                        else {
                            this._position.y = platform.y - 70;
                            this._Jump();
                        }
                        if (platform.type === "droping") {
                            platform.isTouch = true;
                        }
                    }
                }
                if (this._gravitySpeed > 0) {
                    this.isJumping = false;
                }
            }
            _updateScore(deltaY) {
                if (deltaY > 0) {
                    this._score += deltaY;

                    let scoreElement = document.getElementById("score_" + this._id);
                    if (scoreElement) {
                        scoreElement.textContent = `Score: ${Math.floor(this._score)}`;
                    }
                    if (this._score > bestScoreEver) {
                        bestScoreEver = this._score;
                        updateBestScoreDisplay();
                    }
                }
            }

        }

        class View {
            constructor(canvasId) {
                this._canvas = document.getElementById(canvasId);
                this.ctx = this._canvas.getContext('2d');
                this._hold_right = false;
                this._hold_left = false;

                this.doodleImageLeft = new Image();
                this.doodleImageLeft.src = './tiles/doodle-left.png';

                this.doodleImageRight = new Image();
                this.doodleImageRight.src = './tiles/doodle-right.png';

                this.currentDoodleImage = this.doodleImageLeft;

                this.platformSprite = new Image();
                this.platformSprite.src = './tiles/game-tiles.png';

                this.backgroundImage = new Image();
                this.backgroundImage.src = './tiles/background.png';


                this.Events();
                this._resizeCanvas();
                window.addEventListener('resize', this._resizeCanvas.bind(this));
            }


            _resizeCanvas() {
                const canvasWidth = 450;
                const canvasHeight = 750;
                this._canvas.width = canvasWidth;
                this._canvas.height = canvasHeight;
            }

            BindSetDirection(callback) {
                this.b_SetDirection = callback;
            }

            Events() {

            }


            Display(position, direction, platforms, finishLine) {
                let x = position.x;
                let y = position.y;

                this.ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);

                this.ctx.beginPath();
                this.ctx.moveTo(100, 0);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(0, 100);
                this.ctx.stroke();


                if (this.backgroundImage.complete) {
                    this.ctx.drawImage(this.backgroundImage, 0, 0, this._canvas.width, this._canvas.height);
                } else {
                    this.ctx.fillStyle = "lightblue";
                    this.ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
                }

                for (let platform of platforms) {
                    if (platform.y > 0 && platform.y < 750 && platform.y > finishLine.y - 10) {
                        platform.DrawPlateform(this.ctx, this.platformSprite);
                    }
                }

                const colors = ["red", "green", "blue", "orange"];
                this.ctx.lineWidth = 2;

                let sortedPlatforms = platforms
                    .map(p => ({ platform: p, distance: Math.abs(y - p.y) }))
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, 4);

                sortedPlatforms.forEach((item, index) => {
                    this.ctx.strokeStyle = colors[index % colors.length];
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + 30, y + 35);
                    this.ctx.lineTo(item.platform.x + item.platform.width / 2, item.platform.y + item.platform.height / 2); // Centre de la plateforme
                    this.ctx.stroke();
                });

                this.ctx.drawImage(this.currentDoodleImage, x, y, 60, 70);
                this.ctx.drawImage(this.platformSprite, 580, 420, 800, 80, 1, finishLine.y, 1125, 80);


                if (direction < 0) {
                    this.currentDoodleImage = this.doodleImageLeft;
                } else if (direction > 0) {
                    this.currentDoodleImage = this.doodleImageRight;
                }

                this.ctx.drawImage(this.currentDoodleImage, x, y, 60, 70);

            }
        }

        class Controller {
            constructor(model, view) {
                this._model = model;
                this._view = view;

                this._startTime = Date.now();
                this._lag = 0;
                this._fps = 60; // Frame rate.
                this._frameDuration = 1000 / this._fps; // Avec 60 frame par seconde, la frame va durer 16.7ms.

                this._model.BindDisplay(this.Display.bind(this));
                this._view.BindSetDirection(this.SetDirection.bind(this));
            }

            Display(position, direction, platforms, finishLine) {
                this._view.Display(position, direction, platforms, finishLine);
            }

            SetDirection(newDirection) {
                this._model.direction = newDirection;
            }

            Update() {
                if (this._model.isGameOver) {
                    if (checkGenerationOver()) {
                        handleNewGeneration();
                    }
                    return;
                }
                let currentTime = Date.now();
                let deltaTime = currentTime - this._startTime;

                this._lag += deltaTime;
                this._startTime = currentTime;

                while (this._lag >= this._frameDuration) {
                    this._model.Move(this._fps);
                    this._lag -= this._frameDuration;
                }


                requestAnimationFrame(this.Update.bind(this)); // La fonction de rappel est généralement appelée 60 fois par seconde.
            }
        }

        let controllers = [];

        for (let i = 0; i < numDoodles; i++) {
            let model = new Model(
                i,
                randomMatrix(6, 8),
                randomArray(8),
                randomMatrix(8, 16),
                randomArray(8),
                randomMatrix(8, 3),
                randomArray(3)
            );
            let view = new View("canvas_" + i);
            let controller = new Controller(model, view);

            controllers.push(controller);
        }



        controllers.forEach(controller => {
            if (!controller._model.isGameOver) { controller.Update(); }
        });

        // initChart();

        function resetController(newModel) {
            let _newModel = newModel;
            let _view = new View(`canvas_${newModel._id}`);
            let controller = new Controller(_newModel, _view);
            controllers.push(controller);
        }

        function UpdateAllControllers() {
            controllers.forEach(controller => {
                if (!controller._model.isGameOver) { controller.Update(); }
            });
        }

        function updateBestScoreDisplay() {
            const bestScoreElement = document.getElementById("bestScoreContainer");
            if (bestScoreElement) {
                bestScoreElement.textContent = `Best Score: ${Math.floor(bestScoreEver)}`;
            }
        }



        // IA

        function randomMatrix(rows, cols) {
            return Array.from({ length: rows }, () =>
                Array.from({ length: cols }, () => (Math.random() - 0.5) * 2));
        }

        function randomArray(size) {
            return Array.from({ length: size }, () => Math.random() - Math.random());
        }

        function checkGenerationOver() {
            return controllers.every(controller => controller._model.isGameOver);
        }

        function getInputVector(doodle, platforms) {
            let sortedPlatforms = platforms
                .map(platform => ({
                    platform: platform,
                    distance: Math.abs(doodle.y - platform.y)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 4);

            let magnitudes = sortedPlatforms.map(p => p.platform.y / 750);

            let relativeX = doodle.x / 450;
            let relativeY = doodle.y / 450;

            return [...magnitudes, relativeX, relativeY];
        }

        function linearTransformation(inputVector, weights, biases) {
            let outputVector = new Array(weights[0].length).fill(0);  // Nombre de neurones en sortie basé sur les colonnes des poids

            for (let j = 0; j < weights[0].length; j++) {  // Boucle sur les neurones de sortie
                for (let i = 0; i < inputVector.length; i++) {  // Boucle sur les entrées
                    outputVector[j] += inputVector[i] * weights[i][j];
                }
                outputVector[j] += biases[j];  // Ajout du biais
            }

            return outputVector;
        }


        function applyReLU(outputVector) {
            return outputVector.map(o => Math.max(0, o));
        }

        function outputLayer(activatedVector, weights, biaises) {
            let outputVector = new Array(3).fill(0);

            for (let j = 0; j < 3; j++) {
                for (let i = 0; i < 4; i++) {
                    outputVector[j] += activatedVector[i] * weights[i][j];
                }
                outputVector[j] += biaises[j];
            }

            return outputVector;
        }

        function softmax(vector) {
            let expVector = vector.map(Math.exp);
            let sumExp = expVector.reduce((sum, val) => sum + val, 0);
            return expVector.map(val => val / sumExp);
        }

        function chooseAction(actionProbabilities) {
            let actionIndex = actionProbabilities.indexOf(Math.max(...actionProbabilities));

            let actions = [-1, 0, 1];

            return actions[actionIndex];
        }



        function handleNewGeneration() {
            if (!checkGenerationOver(controllers)) return;
            let oldModels = controllers.map(controller => controller._model);
            const newGeneration = createNewGeneration(oldModels, 10, numDoodles);
            models = null;

            controllers = [];
            newGeneration.forEach((newGen, i) => {
                resetController(newGeneration[i]);
            });
            UpdateAllControllers();
        }


        function evaluateModels(oldModels) {
            return [...oldModels].sort((a, b) => b._score - a._score);
        }
        function selectTopModels(oldModels, topN) {
            return oldModels.slice(0, topN);
        }

        function crossover(parent1, parent2, id) {
            let weights1 = parent1.weights1.map((row, i) =>
                row.map((val, j) => Math.random() < 0.5 ? val : parent2.weights1[i][j])
            );
            let biases1 = parent1.biases1.map((val, i) =>
                Math.random() < 0.5 ? val : parent2.biases1[i]
            );

            let weights2 = parent1.weights2.map((row, i) =>
                row.map((val, j) => Math.random() < 0.5 ? val : parent2.weights2[i][j])
            );
            let biases2 = parent1.biases2.map((val, i) =>
                Math.random() < 0.5 ? val : parent2.biases2[i]
            );
            let weights3 = parent1.weights3.map((row, i) =>
                row.map((val, j) => Math.random() < 0.5 ? val : parent2.weights3[i][j])
            );
            let biases3 = parent1.biases3.map((val, i) =>
                Math.random() < 0.5 ? val : parent2.biases3[i]
            );
            const child = new Model(id, weights1, biases1, weights2, biases2, weights3, biases3);
            return child;
        }


        function mutate(model, baseMutationRate = 0.1) {
            let mutationRate = baseMutationRate;

            if (model._score <= 162) {
                mutationRate *= 5;
            }
            else {
                mutationRate *= 0.5;
            }

            model.weights1 = model.weights1.map(row =>
                row.map(val => (Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val))
            );
            model.biases1 = model.biases1.map(val =>
                Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val
            );

            model.weights2 = model.weights2.map(row =>
                row.map(val => (Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val))
            );
            model.biases2 = model.biases2.map(val =>
                Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val
            );

            model.weights3 = model.weights3.map(row =>
                row.map(val => (Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val))
            );
            model.biases3 = model.biases3.map(val =>
                Math.random() < mutationRate ? val + (Math.random() * 0.4 - 0.2) : val
            );
        }



        function createNewGeneration(oldModels, topN, numDoodles) {
            const topModels = selectTopModels(evaluateModels(oldModels), topN);
            const newGeneration = [];

            for (let i = 0; i < topN; i++) {
                const eliteModel = topModels[i];
                const clonedEliteModel = new Model(
                    i,
                    cloneMatrix(eliteModel.weights1),
                    [...eliteModel.biases1],
                    cloneMatrix(eliteModel.weights2),
                    [...eliteModel.biases2],
                    cloneMatrix(eliteModel.weights3),
                    [...eliteModel.biases3]
                );

                newGeneration.push(clonedEliteModel);
            }

            for (let i = topN; i < numDoodles; i++) {
                const parent1 = topModels[Math.floor(Math.random() * topModels.length)];
                const parent2 = topModels[Math.floor(Math.random() * topModels.length)];

                const child = crossover(parent1, parent2, i);
                mutate(child);
                newGeneration.push(child);
            }

            return newGeneration;
        }
        function cloneMatrix(matrix) {
            return matrix.map(row => [...row]);
        }



    </script>

</body>

</html>